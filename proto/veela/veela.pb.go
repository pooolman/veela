// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: veela.proto

package veela

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type StatusCode int32

const (
	StatusCode_OK                     StatusCode = 0
	StatusCode_UNSPECIFIED            StatusCode = 1
	StatusCode_TIMEOUT                StatusCode = 2
	StatusCode_GROUP_NAME_DONT_MATCH  StatusCode = 3
	StatusCode_ACCEPTOR_ID_DONT_MATCH StatusCode = 4
	StatusCode_EAGAIN                 StatusCode = 5
	StatusCode_RESOURCE_UNAVAILABLE   StatusCode = 6
)

var StatusCode_name = map[int32]string{
	0: "OK",
	1: "UNSPECIFIED",
	2: "TIMEOUT",
	3: "GROUP_NAME_DONT_MATCH",
	4: "ACCEPTOR_ID_DONT_MATCH",
	5: "EAGAIN",
	6: "RESOURCE_UNAVAILABLE",
}

var StatusCode_value = map[string]int32{
	"OK":                     0,
	"UNSPECIFIED":            1,
	"TIMEOUT":                2,
	"GROUP_NAME_DONT_MATCH":  3,
	"ACCEPTOR_ID_DONT_MATCH": 4,
	"EAGAIN":                 5,
	"RESOURCE_UNAVAILABLE":   6,
}

func (x StatusCode) String() string {
	return proto.EnumName(StatusCode_name, int32(x))
}

func (StatusCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_cb58611707007930, []int{0}
}

type NetworkAddr struct {
	Protocol string `protobuf:"bytes,1,opt,name=protocol,proto3" json:"protocol,omitempty"`
	Ip       string `protobuf:"bytes,2,opt,name=ip,proto3" json:"ip,omitempty"`
	Port     uint32 `protobuf:"varint,3,opt,name=port,proto3" json:"port,omitempty"`
}

func (m *NetworkAddr) Reset()         { *m = NetworkAddr{} }
func (m *NetworkAddr) String() string { return proto.CompactTextString(m) }
func (*NetworkAddr) ProtoMessage()    {}
func (*NetworkAddr) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb58611707007930, []int{0}
}
func (m *NetworkAddr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NetworkAddr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NetworkAddr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NetworkAddr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NetworkAddr.Merge(m, src)
}
func (m *NetworkAddr) XXX_Size() int {
	return m.Size()
}
func (m *NetworkAddr) XXX_DiscardUnknown() {
	xxx_messageInfo_NetworkAddr.DiscardUnknown(m)
}

var xxx_messageInfo_NetworkAddr proto.InternalMessageInfo

func (m *NetworkAddr) GetProtocol() string {
	if m != nil {
		return m.Protocol
	}
	return ""
}

func (m *NetworkAddr) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *NetworkAddr) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type ElectionResult struct {
	// must >= 2
	TermLen int32 `protobuf:"varint,1,opt,name=termLen,proto3" json:"termLen,omitempty"`
	// ascending order
	AcceptorIDArray []uint64 `protobuf:"varint,2,rep,packed,name=acceptorIDArray,proto3" json:"acceptorIDArray,omitempty"`
}

func (m *ElectionResult) Reset()         { *m = ElectionResult{} }
func (m *ElectionResult) String() string { return proto.CompactTextString(m) }
func (*ElectionResult) ProtoMessage()    {}
func (*ElectionResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb58611707007930, []int{1}
}
func (m *ElectionResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ElectionResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ElectionResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ElectionResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ElectionResult.Merge(m, src)
}
func (m *ElectionResult) XXX_Size() int {
	return m.Size()
}
func (m *ElectionResult) XXX_DiscardUnknown() {
	xxx_messageInfo_ElectionResult.DiscardUnknown(m)
}

var xxx_messageInfo_ElectionResult proto.InternalMessageInfo

func (m *ElectionResult) GetTermLen() int32 {
	if m != nil {
		return m.TermLen
	}
	return 0
}

func (m *ElectionResult) GetAcceptorIDArray() []uint64 {
	if m != nil {
		return m.AcceptorIDArray
	}
	return nil
}

type AcceptValueMemberIdx struct {
	Offset int32 `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"`
	Len    int32 `protobuf:"varint,2,opt,name=len,proto3" json:"len,omitempty"`
}

func (m *AcceptValueMemberIdx) Reset()         { *m = AcceptValueMemberIdx{} }
func (m *AcceptValueMemberIdx) String() string { return proto.CompactTextString(m) }
func (*AcceptValueMemberIdx) ProtoMessage()    {}
func (*AcceptValueMemberIdx) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb58611707007930, []int{2}
}
func (m *AcceptValueMemberIdx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptValueMemberIdx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptValueMemberIdx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptValueMemberIdx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptValueMemberIdx.Merge(m, src)
}
func (m *AcceptValueMemberIdx) XXX_Size() int {
	return m.Size()
}
func (m *AcceptValueMemberIdx) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptValueMemberIdx.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptValueMemberIdx proto.InternalMessageInfo

func (m *AcceptValueMemberIdx) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *AcceptValueMemberIdx) GetLen() int32 {
	if m != nil {
		return m.Len
	}
	return 0
}

type AcceptValueMemberIdxs struct {
	Idxs []*AcceptValueMemberIdx `protobuf:"bytes,1,rep,name=idxs,proto3" json:"idxs,omitempty"`
}

func (m *AcceptValueMemberIdxs) Reset()         { *m = AcceptValueMemberIdxs{} }
func (m *AcceptValueMemberIdxs) String() string { return proto.CompactTextString(m) }
func (*AcceptValueMemberIdxs) ProtoMessage()    {}
func (*AcceptValueMemberIdxs) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb58611707007930, []int{3}
}
func (m *AcceptValueMemberIdxs) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptValueMemberIdxs) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptValueMemberIdxs.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptValueMemberIdxs) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptValueMemberIdxs.Merge(m, src)
}
func (m *AcceptValueMemberIdxs) XXX_Size() int {
	return m.Size()
}
func (m *AcceptValueMemberIdxs) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptValueMemberIdxs.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptValueMemberIdxs proto.InternalMessageInfo

func (m *AcceptValueMemberIdxs) GetIdxs() []*AcceptValueMemberIdx {
	if m != nil {
		return m.Idxs
	}
	return nil
}

type AcceptorInOnePaxosInstanceState struct {
	ChosenFlag bool `protobuf:"varint,1,opt,name=chosenFlag,proto3" json:"chosenFlag,omitempty"`
	// p_e: zero means init state
	PrepareEpoch uint64 `protobuf:"varint,2,opt,name=prepareEpoch,proto3" json:"prepareEpoch,omitempty"`
	// a_e: zero means invalid
	AcceptEpoch uint64 `protobuf:"varint,3,opt,name=acceptEpoch,proto3" json:"acceptEpoch,omitempty"`
	// a_v_id: zero means invalid
	AcceptValueID uint64 `protobuf:"varint,4,opt,name=acceptValueID,proto3" json:"acceptValueID,omitempty"`
	// acceptValueID map to logdb idx which stores the marshaled accept value
	AcceptValueLogdbIdxMap map[uint64]uint64 `protobuf:"bytes,5,rep,name=acceptValueLogdbIdxMap,proto3" json:"acceptValueLogdbIdxMap,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *AcceptorInOnePaxosInstanceState) Reset()         { *m = AcceptorInOnePaxosInstanceState{} }
func (m *AcceptorInOnePaxosInstanceState) String() string { return proto.CompactTextString(m) }
func (*AcceptorInOnePaxosInstanceState) ProtoMessage()    {}
func (*AcceptorInOnePaxosInstanceState) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb58611707007930, []int{4}
}
func (m *AcceptorInOnePaxosInstanceState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptorInOnePaxosInstanceState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptorInOnePaxosInstanceState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptorInOnePaxosInstanceState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptorInOnePaxosInstanceState.Merge(m, src)
}
func (m *AcceptorInOnePaxosInstanceState) XXX_Size() int {
	return m.Size()
}
func (m *AcceptorInOnePaxosInstanceState) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptorInOnePaxosInstanceState.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptorInOnePaxosInstanceState proto.InternalMessageInfo

func (m *AcceptorInOnePaxosInstanceState) GetChosenFlag() bool {
	if m != nil {
		return m.ChosenFlag
	}
	return false
}

func (m *AcceptorInOnePaxosInstanceState) GetPrepareEpoch() uint64 {
	if m != nil {
		return m.PrepareEpoch
	}
	return 0
}

func (m *AcceptorInOnePaxosInstanceState) GetAcceptEpoch() uint64 {
	if m != nil {
		return m.AcceptEpoch
	}
	return 0
}

func (m *AcceptorInOnePaxosInstanceState) GetAcceptValueID() uint64 {
	if m != nil {
		return m.AcceptValueID
	}
	return 0
}

func (m *AcceptorInOnePaxosInstanceState) GetAcceptValueLogdbIdxMap() map[uint64]uint64 {
	if m != nil {
		return m.AcceptValueLogdbIdxMap
	}
	return nil
}

type AcceptorIDMapToNetworkAddr struct {
	AcceptorIDMapToNetworkAddr map[uint64]*NetworkAddr `protobuf:"bytes,1,rep,name=acceptorIDMapToNetworkAddr,proto3" json:"acceptorIDMapToNetworkAddr,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AcceptorIDMapToNetworkAddr) Reset()         { *m = AcceptorIDMapToNetworkAddr{} }
func (m *AcceptorIDMapToNetworkAddr) String() string { return proto.CompactTextString(m) }
func (*AcceptorIDMapToNetworkAddr) ProtoMessage()    {}
func (*AcceptorIDMapToNetworkAddr) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb58611707007930, []int{5}
}
func (m *AcceptorIDMapToNetworkAddr) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptorIDMapToNetworkAddr) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptorIDMapToNetworkAddr.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptorIDMapToNetworkAddr) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptorIDMapToNetworkAddr.Merge(m, src)
}
func (m *AcceptorIDMapToNetworkAddr) XXX_Size() int {
	return m.Size()
}
func (m *AcceptorIDMapToNetworkAddr) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptorIDMapToNetworkAddr.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptorIDMapToNetworkAddr proto.InternalMessageInfo

func (m *AcceptorIDMapToNetworkAddr) GetAcceptorIDMapToNetworkAddr() map[uint64]*NetworkAddr {
	if m != nil {
		return m.AcceptorIDMapToNetworkAddr
	}
	return nil
}

type AcceptorTermState struct {
	StartFromInstE uint64          `protobuf:"varint,1,opt,name=startFromInstE,proto3" json:"startFromInstE,omitempty"`
	ElectionResult *ElectionResult `protobuf:"bytes,2,opt,name=electionResult,proto3" json:"electionResult,omitempty"`
	// 	map: acceptorIDs -> acceptorAddrHints
	AcceptorIDMapToNetworkAddr *AcceptorIDMapToNetworkAddr `protobuf:"bytes,3,opt,name=acceptorIDMapToNetworkAddr,proto3" json:"acceptorIDMapToNetworkAddr,omitempty"`
	// if true means all inst in this election term has already been chosen
	AllChosenFlag                        bool                               `protobuf:"varint,4,opt,name=allChosenFlag,proto3" json:"allChosenFlag,omitempty"`
	AcceptorInOnePaxosInstanceStateArray []*AcceptorInOnePaxosInstanceState `protobuf:"bytes,5,rep,name=acceptorInOnePaxosInstanceStateArray,proto3" json:"acceptorInOnePaxosInstanceStateArray,omitempty"`
	// zero means end
	LogdbIdxOfLastAcceptorTermState uint64 `protobuf:"varint,6,opt,name=logdbIdxOfLastAcceptorTermState,proto3" json:"logdbIdxOfLastAcceptorTermState,omitempty"`
}

func (m *AcceptorTermState) Reset()         { *m = AcceptorTermState{} }
func (m *AcceptorTermState) String() string { return proto.CompactTextString(m) }
func (*AcceptorTermState) ProtoMessage()    {}
func (*AcceptorTermState) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb58611707007930, []int{6}
}
func (m *AcceptorTermState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptorTermState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptorTermState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptorTermState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptorTermState.Merge(m, src)
}
func (m *AcceptorTermState) XXX_Size() int {
	return m.Size()
}
func (m *AcceptorTermState) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptorTermState.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptorTermState proto.InternalMessageInfo

func (m *AcceptorTermState) GetStartFromInstE() uint64 {
	if m != nil {
		return m.StartFromInstE
	}
	return 0
}

func (m *AcceptorTermState) GetElectionResult() *ElectionResult {
	if m != nil {
		return m.ElectionResult
	}
	return nil
}

func (m *AcceptorTermState) GetAcceptorIDMapToNetworkAddr() *AcceptorIDMapToNetworkAddr {
	if m != nil {
		return m.AcceptorIDMapToNetworkAddr
	}
	return nil
}

func (m *AcceptorTermState) GetAllChosenFlag() bool {
	if m != nil {
		return m.AllChosenFlag
	}
	return false
}

func (m *AcceptorTermState) GetAcceptorInOnePaxosInstanceStateArray() []*AcceptorInOnePaxosInstanceState {
	if m != nil {
		return m.AcceptorInOnePaxosInstanceStateArray
	}
	return nil
}

func (m *AcceptorTermState) GetLogdbIdxOfLastAcceptorTermState() uint64 {
	if m != nil {
		return m.LogdbIdxOfLastAcceptorTermState
	}
	return 0
}

type AcceptorStateSummary struct {
	DeleteInstBeforeEpoch       uint64 `protobuf:"varint,1,opt,name=deleteInstBeforeEpoch,proto3" json:"deleteInstBeforeEpoch,omitempty"`
	CurrentInstEpochRangeLeftE  uint64 `protobuf:"varint,2,opt,name=currentInstEpochRangeLeftE,proto3" json:"currentInstEpochRangeLeftE,omitempty"`
	CurrentInstEpochRangeRightE uint64 `protobuf:"varint,3,opt,name=currentInstEpochRangeRightE,proto3" json:"currentInstEpochRangeRightE,omitempty"`
	// ascending order by `startFromInstE` and must be continuous
	AcceptorTermStates []*AcceptorTermState `protobuf:"bytes,4,rep,name=acceptorTermStates,proto3" json:"acceptorTermStates,omitempty"`
}

func (m *AcceptorStateSummary) Reset()         { *m = AcceptorStateSummary{} }
func (m *AcceptorStateSummary) String() string { return proto.CompactTextString(m) }
func (*AcceptorStateSummary) ProtoMessage()    {}
func (*AcceptorStateSummary) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb58611707007930, []int{7}
}
func (m *AcceptorStateSummary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptorStateSummary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptorStateSummary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptorStateSummary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptorStateSummary.Merge(m, src)
}
func (m *AcceptorStateSummary) XXX_Size() int {
	return m.Size()
}
func (m *AcceptorStateSummary) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptorStateSummary.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptorStateSummary proto.InternalMessageInfo

func (m *AcceptorStateSummary) GetDeleteInstBeforeEpoch() uint64 {
	if m != nil {
		return m.DeleteInstBeforeEpoch
	}
	return 0
}

func (m *AcceptorStateSummary) GetCurrentInstEpochRangeLeftE() uint64 {
	if m != nil {
		return m.CurrentInstEpochRangeLeftE
	}
	return 0
}

func (m *AcceptorStateSummary) GetCurrentInstEpochRangeRightE() uint64 {
	if m != nil {
		return m.CurrentInstEpochRangeRightE
	}
	return 0
}

func (m *AcceptorStateSummary) GetAcceptorTermStates() []*AcceptorTermState {
	if m != nil {
		return m.AcceptorTermStates
	}
	return nil
}

type AcceptorRpcPrepareRequest struct {
	GroupName string `protobuf:"bytes,1,opt,name=groupName,proto3" json:"groupName,omitempty"`
	// zero means it is not a proposer
	ProposerID uint64 `protobuf:"varint,2,opt,name=proposerID,proto3" json:"proposerID,omitempty"`
	// must > 0
	AcceptorID uint64 `protobuf:"varint,3,opt,name=acceptorID,proto3" json:"acceptorID,omitempty"`
	// must > 0
	InstE                       uint64 `protobuf:"varint,4,opt,name=instE,proto3" json:"instE,omitempty"`
	PrepareEpoch                uint64 `protobuf:"varint,5,opt,name=prepareEpoch,proto3" json:"prepareEpoch,omitempty"`
	OnlyRetureAcceptValueIDFlag bool   `protobuf:"varint,6,opt,name=onlyRetureAcceptValueIDFlag,proto3" json:"onlyRetureAcceptValueIDFlag,omitempty"`
}

func (m *AcceptorRpcPrepareRequest) Reset()         { *m = AcceptorRpcPrepareRequest{} }
func (m *AcceptorRpcPrepareRequest) String() string { return proto.CompactTextString(m) }
func (*AcceptorRpcPrepareRequest) ProtoMessage()    {}
func (*AcceptorRpcPrepareRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb58611707007930, []int{8}
}
func (m *AcceptorRpcPrepareRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptorRpcPrepareRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptorRpcPrepareRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptorRpcPrepareRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptorRpcPrepareRequest.Merge(m, src)
}
func (m *AcceptorRpcPrepareRequest) XXX_Size() int {
	return m.Size()
}
func (m *AcceptorRpcPrepareRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptorRpcPrepareRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptorRpcPrepareRequest proto.InternalMessageInfo

func (m *AcceptorRpcPrepareRequest) GetGroupName() string {
	if m != nil {
		return m.GroupName
	}
	return ""
}

func (m *AcceptorRpcPrepareRequest) GetProposerID() uint64 {
	if m != nil {
		return m.ProposerID
	}
	return 0
}

func (m *AcceptorRpcPrepareRequest) GetAcceptorID() uint64 {
	if m != nil {
		return m.AcceptorID
	}
	return 0
}

func (m *AcceptorRpcPrepareRequest) GetInstE() uint64 {
	if m != nil {
		return m.InstE
	}
	return 0
}

func (m *AcceptorRpcPrepareRequest) GetPrepareEpoch() uint64 {
	if m != nil {
		return m.PrepareEpoch
	}
	return 0
}

func (m *AcceptorRpcPrepareRequest) GetOnlyRetureAcceptValueIDFlag() bool {
	if m != nil {
		return m.OnlyRetureAcceptValueIDFlag
	}
	return false
}

type AcceptorRpcPrepareResponese struct {
	StatusCode                      int32                            `protobuf:"varint,1,opt,name=statusCode,proto3" json:"statusCode,omitempty"`
	ErrStr                          string                           `protobuf:"bytes,2,opt,name=errStr,proto3" json:"errStr,omitempty"`
	PromisedFlag                    bool                             `protobuf:"varint,3,opt,name=promisedFlag,proto3" json:"promisedFlag,omitempty"`
	AcceptorInOnePaxosInstanceState *AcceptorInOnePaxosInstanceState `protobuf:"bytes,4,opt,name=acceptorInOnePaxosInstanceState,proto3" json:"acceptorInOnePaxosInstanceState,omitempty"`
	// valid AcceptValueBs' len should always > 0
	AcceptValueIDMapToAcceptValueBs map[uint64][]byte `protobuf:"bytes,5,rep,name=acceptValueIDMapToAcceptValueBs,proto3" json:"acceptValueIDMapToAcceptValueBs,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AcceptorRpcPrepareResponese) Reset()         { *m = AcceptorRpcPrepareResponese{} }
func (m *AcceptorRpcPrepareResponese) String() string { return proto.CompactTextString(m) }
func (*AcceptorRpcPrepareResponese) ProtoMessage()    {}
func (*AcceptorRpcPrepareResponese) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb58611707007930, []int{9}
}
func (m *AcceptorRpcPrepareResponese) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptorRpcPrepareResponese) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptorRpcPrepareResponese.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptorRpcPrepareResponese) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptorRpcPrepareResponese.Merge(m, src)
}
func (m *AcceptorRpcPrepareResponese) XXX_Size() int {
	return m.Size()
}
func (m *AcceptorRpcPrepareResponese) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptorRpcPrepareResponese.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptorRpcPrepareResponese proto.InternalMessageInfo

func (m *AcceptorRpcPrepareResponese) GetStatusCode() int32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

func (m *AcceptorRpcPrepareResponese) GetErrStr() string {
	if m != nil {
		return m.ErrStr
	}
	return ""
}

func (m *AcceptorRpcPrepareResponese) GetPromisedFlag() bool {
	if m != nil {
		return m.PromisedFlag
	}
	return false
}

func (m *AcceptorRpcPrepareResponese) GetAcceptorInOnePaxosInstanceState() *AcceptorInOnePaxosInstanceState {
	if m != nil {
		return m.AcceptorInOnePaxosInstanceState
	}
	return nil
}

func (m *AcceptorRpcPrepareResponese) GetAcceptValueIDMapToAcceptValueBs() map[uint64][]byte {
	if m != nil {
		return m.AcceptValueIDMapToAcceptValueBs
	}
	return nil
}

type AcceptorRpcAcceptRequest struct {
	GroupName string `protobuf:"bytes,1,opt,name=groupName,proto3" json:"groupName,omitempty"`
	// zero means it is not a proposer
	ProposerID uint64 `protobuf:"varint,2,opt,name=proposerID,proto3" json:"proposerID,omitempty"`
	// must > 0
	AcceptorID uint64 `protobuf:"varint,3,opt,name=acceptorID,proto3" json:"acceptorID,omitempty"`
	// must > 0
	InstE                        uint64 `protobuf:"varint,4,opt,name=instE,proto3" json:"instE,omitempty"`
	PreparedEpoch                uint64 `protobuf:"varint,5,opt,name=preparedEpoch,proto3" json:"preparedEpoch,omitempty"`
	ToAcceptValueID              uint64 `protobuf:"varint,6,opt,name=toAcceptValueID,proto3" json:"toAcceptValueID,omitempty"`
	OnlyContainAcceptValueIDFlag bool   `protobuf:"varint,7,opt,name=onlyContainAcceptValueIDFlag,proto3" json:"onlyContainAcceptValueIDFlag,omitempty"`
	ToAcceptValueBs              []byte `protobuf:"bytes,8,opt,name=toAcceptValueBs,proto3" json:"toAcceptValueBs,omitempty"`
}

func (m *AcceptorRpcAcceptRequest) Reset()         { *m = AcceptorRpcAcceptRequest{} }
func (m *AcceptorRpcAcceptRequest) String() string { return proto.CompactTextString(m) }
func (*AcceptorRpcAcceptRequest) ProtoMessage()    {}
func (*AcceptorRpcAcceptRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb58611707007930, []int{10}
}
func (m *AcceptorRpcAcceptRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptorRpcAcceptRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptorRpcAcceptRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptorRpcAcceptRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptorRpcAcceptRequest.Merge(m, src)
}
func (m *AcceptorRpcAcceptRequest) XXX_Size() int {
	return m.Size()
}
func (m *AcceptorRpcAcceptRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptorRpcAcceptRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptorRpcAcceptRequest proto.InternalMessageInfo

func (m *AcceptorRpcAcceptRequest) GetGroupName() string {
	if m != nil {
		return m.GroupName
	}
	return ""
}

func (m *AcceptorRpcAcceptRequest) GetProposerID() uint64 {
	if m != nil {
		return m.ProposerID
	}
	return 0
}

func (m *AcceptorRpcAcceptRequest) GetAcceptorID() uint64 {
	if m != nil {
		return m.AcceptorID
	}
	return 0
}

func (m *AcceptorRpcAcceptRequest) GetInstE() uint64 {
	if m != nil {
		return m.InstE
	}
	return 0
}

func (m *AcceptorRpcAcceptRequest) GetPreparedEpoch() uint64 {
	if m != nil {
		return m.PreparedEpoch
	}
	return 0
}

func (m *AcceptorRpcAcceptRequest) GetToAcceptValueID() uint64 {
	if m != nil {
		return m.ToAcceptValueID
	}
	return 0
}

func (m *AcceptorRpcAcceptRequest) GetOnlyContainAcceptValueIDFlag() bool {
	if m != nil {
		return m.OnlyContainAcceptValueIDFlag
	}
	return false
}

func (m *AcceptorRpcAcceptRequest) GetToAcceptValueBs() []byte {
	if m != nil {
		return m.ToAcceptValueBs
	}
	return nil
}

type AcceptorRpcAcceptResponse struct {
	StatusCode                      int32                            `protobuf:"varint,1,opt,name=statusCode,proto3" json:"statusCode,omitempty"`
	ErrStr                          string                           `protobuf:"bytes,2,opt,name=errStr,proto3" json:"errStr,omitempty"`
	AcceptedFlag                    bool                             `protobuf:"varint,3,opt,name=acceptedFlag,proto3" json:"acceptedFlag,omitempty"`
	AcceptorInOnePaxosInstanceState *AcceptorInOnePaxosInstanceState `protobuf:"bytes,4,opt,name=acceptorInOnePaxosInstanceState,proto3" json:"acceptorInOnePaxosInstanceState,omitempty"`
}

func (m *AcceptorRpcAcceptResponse) Reset()         { *m = AcceptorRpcAcceptResponse{} }
func (m *AcceptorRpcAcceptResponse) String() string { return proto.CompactTextString(m) }
func (*AcceptorRpcAcceptResponse) ProtoMessage()    {}
func (*AcceptorRpcAcceptResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb58611707007930, []int{11}
}
func (m *AcceptorRpcAcceptResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptorRpcAcceptResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptorRpcAcceptResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptorRpcAcceptResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptorRpcAcceptResponse.Merge(m, src)
}
func (m *AcceptorRpcAcceptResponse) XXX_Size() int {
	return m.Size()
}
func (m *AcceptorRpcAcceptResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptorRpcAcceptResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptorRpcAcceptResponse proto.InternalMessageInfo

func (m *AcceptorRpcAcceptResponse) GetStatusCode() int32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

func (m *AcceptorRpcAcceptResponse) GetErrStr() string {
	if m != nil {
		return m.ErrStr
	}
	return ""
}

func (m *AcceptorRpcAcceptResponse) GetAcceptedFlag() bool {
	if m != nil {
		return m.AcceptedFlag
	}
	return false
}

func (m *AcceptorRpcAcceptResponse) GetAcceptorInOnePaxosInstanceState() *AcceptorInOnePaxosInstanceState {
	if m != nil {
		return m.AcceptorInOnePaxosInstanceState
	}
	return nil
}

type AcceptorRpcChosenNotifyRequest struct {
	GroupName string `protobuf:"bytes,1,opt,name=groupName,proto3" json:"groupName,omitempty"`
	// zero means it is not a proposer
	ProposerID uint64 `protobuf:"varint,2,opt,name=proposerID,proto3" json:"proposerID,omitempty"`
	// must > 0
	AcceptorID uint64 `protobuf:"varint,3,opt,name=acceptorID,proto3" json:"acceptorID,omitempty"`
	// must > 0
	InstE                        uint64 `protobuf:"varint,4,opt,name=instE,proto3" json:"instE,omitempty"`
	AcceptValueID                uint64 `protobuf:"varint,5,opt,name=acceptValueID,proto3" json:"acceptValueID,omitempty"`
	OnlyContainAcceptValueIDFlag bool   `protobuf:"varint,6,opt,name=onlyContainAcceptValueIDFlag,proto3" json:"onlyContainAcceptValueIDFlag,omitempty"`
	AcceptValueBs                uint64 `protobuf:"varint,7,opt,name=acceptValueBs,proto3" json:"acceptValueBs,omitempty"`
}

func (m *AcceptorRpcChosenNotifyRequest) Reset()         { *m = AcceptorRpcChosenNotifyRequest{} }
func (m *AcceptorRpcChosenNotifyRequest) String() string { return proto.CompactTextString(m) }
func (*AcceptorRpcChosenNotifyRequest) ProtoMessage()    {}
func (*AcceptorRpcChosenNotifyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb58611707007930, []int{12}
}
func (m *AcceptorRpcChosenNotifyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptorRpcChosenNotifyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptorRpcChosenNotifyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptorRpcChosenNotifyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptorRpcChosenNotifyRequest.Merge(m, src)
}
func (m *AcceptorRpcChosenNotifyRequest) XXX_Size() int {
	return m.Size()
}
func (m *AcceptorRpcChosenNotifyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptorRpcChosenNotifyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptorRpcChosenNotifyRequest proto.InternalMessageInfo

func (m *AcceptorRpcChosenNotifyRequest) GetGroupName() string {
	if m != nil {
		return m.GroupName
	}
	return ""
}

func (m *AcceptorRpcChosenNotifyRequest) GetProposerID() uint64 {
	if m != nil {
		return m.ProposerID
	}
	return 0
}

func (m *AcceptorRpcChosenNotifyRequest) GetAcceptorID() uint64 {
	if m != nil {
		return m.AcceptorID
	}
	return 0
}

func (m *AcceptorRpcChosenNotifyRequest) GetInstE() uint64 {
	if m != nil {
		return m.InstE
	}
	return 0
}

func (m *AcceptorRpcChosenNotifyRequest) GetAcceptValueID() uint64 {
	if m != nil {
		return m.AcceptValueID
	}
	return 0
}

func (m *AcceptorRpcChosenNotifyRequest) GetOnlyContainAcceptValueIDFlag() bool {
	if m != nil {
		return m.OnlyContainAcceptValueIDFlag
	}
	return false
}

func (m *AcceptorRpcChosenNotifyRequest) GetAcceptValueBs() uint64 {
	if m != nil {
		return m.AcceptValueBs
	}
	return 0
}

type AcceptorRpcChosenNotifyResponse struct {
	StatusCode int32  `protobuf:"varint,1,opt,name=statusCode,proto3" json:"statusCode,omitempty"`
	ErrStr     string `protobuf:"bytes,2,opt,name=errStr,proto3" json:"errStr,omitempty"`
	ChosenFlag bool   `protobuf:"varint,3,opt,name=chosenFlag,proto3" json:"chosenFlag,omitempty"`
}

func (m *AcceptorRpcChosenNotifyResponse) Reset()         { *m = AcceptorRpcChosenNotifyResponse{} }
func (m *AcceptorRpcChosenNotifyResponse) String() string { return proto.CompactTextString(m) }
func (*AcceptorRpcChosenNotifyResponse) ProtoMessage()    {}
func (*AcceptorRpcChosenNotifyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb58611707007930, []int{13}
}
func (m *AcceptorRpcChosenNotifyResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptorRpcChosenNotifyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptorRpcChosenNotifyResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptorRpcChosenNotifyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptorRpcChosenNotifyResponse.Merge(m, src)
}
func (m *AcceptorRpcChosenNotifyResponse) XXX_Size() int {
	return m.Size()
}
func (m *AcceptorRpcChosenNotifyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptorRpcChosenNotifyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptorRpcChosenNotifyResponse proto.InternalMessageInfo

func (m *AcceptorRpcChosenNotifyResponse) GetStatusCode() int32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

func (m *AcceptorRpcChosenNotifyResponse) GetErrStr() string {
	if m != nil {
		return m.ErrStr
	}
	return ""
}

func (m *AcceptorRpcChosenNotifyResponse) GetChosenFlag() bool {
	if m != nil {
		return m.ChosenFlag
	}
	return false
}

type AcceptorRpcGetAcceptValueByIDRequest struct {
	GroupName string `protobuf:"bytes,1,opt,name=groupName,proto3" json:"groupName,omitempty"`
	// zero means it is not a proposer
	ProposerID uint64 `protobuf:"varint,2,opt,name=proposerID,proto3" json:"proposerID,omitempty"`
	// must > 0
	AcceptorID uint64 `protobuf:"varint,3,opt,name=acceptorID,proto3" json:"acceptorID,omitempty"`
	// must > 0
	InstE          uint64   `protobuf:"varint,4,opt,name=instE,proto3" json:"instE,omitempty"`
	AcceptValueIDs []uint64 `protobuf:"varint,5,rep,packed,name=acceptValueIDs,proto3" json:"acceptValueIDs,omitempty"`
}

func (m *AcceptorRpcGetAcceptValueByIDRequest) Reset()         { *m = AcceptorRpcGetAcceptValueByIDRequest{} }
func (m *AcceptorRpcGetAcceptValueByIDRequest) String() string { return proto.CompactTextString(m) }
func (*AcceptorRpcGetAcceptValueByIDRequest) ProtoMessage()    {}
func (*AcceptorRpcGetAcceptValueByIDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb58611707007930, []int{14}
}
func (m *AcceptorRpcGetAcceptValueByIDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptorRpcGetAcceptValueByIDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptorRpcGetAcceptValueByIDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptorRpcGetAcceptValueByIDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptorRpcGetAcceptValueByIDRequest.Merge(m, src)
}
func (m *AcceptorRpcGetAcceptValueByIDRequest) XXX_Size() int {
	return m.Size()
}
func (m *AcceptorRpcGetAcceptValueByIDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptorRpcGetAcceptValueByIDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptorRpcGetAcceptValueByIDRequest proto.InternalMessageInfo

func (m *AcceptorRpcGetAcceptValueByIDRequest) GetGroupName() string {
	if m != nil {
		return m.GroupName
	}
	return ""
}

func (m *AcceptorRpcGetAcceptValueByIDRequest) GetProposerID() uint64 {
	if m != nil {
		return m.ProposerID
	}
	return 0
}

func (m *AcceptorRpcGetAcceptValueByIDRequest) GetAcceptorID() uint64 {
	if m != nil {
		return m.AcceptorID
	}
	return 0
}

func (m *AcceptorRpcGetAcceptValueByIDRequest) GetInstE() uint64 {
	if m != nil {
		return m.InstE
	}
	return 0
}

func (m *AcceptorRpcGetAcceptValueByIDRequest) GetAcceptValueIDs() []uint64 {
	if m != nil {
		return m.AcceptValueIDs
	}
	return nil
}

type AcceptorRpcGetAcceptValueByIDResponse struct {
	StatusCode                      int32                            `protobuf:"varint,1,opt,name=statusCode,proto3" json:"statusCode,omitempty"`
	ErrStr                          string                           `protobuf:"bytes,2,opt,name=errStr,proto3" json:"errStr,omitempty"`
	AcceptorInOnePaxosInstanceState *AcceptorInOnePaxosInstanceState `protobuf:"bytes,3,opt,name=acceptorInOnePaxosInstanceState,proto3" json:"acceptorInOnePaxosInstanceState,omitempty"`
	AcceptValueIDMapToAcceptValueBs map[uint64][]byte                `protobuf:"bytes,4,rep,name=acceptValueIDMapToAcceptValueBs,proto3" json:"acceptValueIDMapToAcceptValueBs,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *AcceptorRpcGetAcceptValueByIDResponse) Reset()         { *m = AcceptorRpcGetAcceptValueByIDResponse{} }
func (m *AcceptorRpcGetAcceptValueByIDResponse) String() string { return proto.CompactTextString(m) }
func (*AcceptorRpcGetAcceptValueByIDResponse) ProtoMessage()    {}
func (*AcceptorRpcGetAcceptValueByIDResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb58611707007930, []int{15}
}
func (m *AcceptorRpcGetAcceptValueByIDResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptorRpcGetAcceptValueByIDResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptorRpcGetAcceptValueByIDResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptorRpcGetAcceptValueByIDResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptorRpcGetAcceptValueByIDResponse.Merge(m, src)
}
func (m *AcceptorRpcGetAcceptValueByIDResponse) XXX_Size() int {
	return m.Size()
}
func (m *AcceptorRpcGetAcceptValueByIDResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptorRpcGetAcceptValueByIDResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptorRpcGetAcceptValueByIDResponse proto.InternalMessageInfo

func (m *AcceptorRpcGetAcceptValueByIDResponse) GetStatusCode() int32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

func (m *AcceptorRpcGetAcceptValueByIDResponse) GetErrStr() string {
	if m != nil {
		return m.ErrStr
	}
	return ""
}

func (m *AcceptorRpcGetAcceptValueByIDResponse) GetAcceptorInOnePaxosInstanceState() *AcceptorInOnePaxosInstanceState {
	if m != nil {
		return m.AcceptorInOnePaxosInstanceState
	}
	return nil
}

func (m *AcceptorRpcGetAcceptValueByIDResponse) GetAcceptValueIDMapToAcceptValueBs() map[uint64][]byte {
	if m != nil {
		return m.AcceptValueIDMapToAcceptValueBs
	}
	return nil
}

type AcceptorRpcGetSummaryRequest struct {
	GroupName string `protobuf:"bytes,1,opt,name=groupName,proto3" json:"groupName,omitempty"`
	// zero means it is not a proposer
	ProposerID uint64 `protobuf:"varint,2,opt,name=proposerID,proto3" json:"proposerID,omitempty"`
	// must > 0
	AcceptorID uint64 `protobuf:"varint,3,opt,name=acceptorID,proto3" json:"acceptorID,omitempty"`
	// true: which means always get the latest N terms and must have unchosen inst in each term
	OnlyGetTermsContainUnchosenInstFlag bool `protobuf:"varint,4,opt,name=onlyGetTermsContainUnchosenInstFlag,proto3" json:"onlyGetTermsContainUnchosenInstFlag,omitempty"`
	// only valid when onlyGetTermsContainUnchosenInstFlag is false
	// interval [getInstEpochRangeLeftE, getInstEpochRangeRightE] must contain one or serveral continuous whole terms
	GetInstEpochRangeLeftE  uint64 `protobuf:"varint,5,opt,name=getInstEpochRangeLeftE,proto3" json:"getInstEpochRangeLeftE,omitempty"`
	GetInstEpochRangeRightE uint64 `protobuf:"varint,6,opt,name=getInstEpochRangeRightE,proto3" json:"getInstEpochRangeRightE,omitempty"`
}

func (m *AcceptorRpcGetSummaryRequest) Reset()         { *m = AcceptorRpcGetSummaryRequest{} }
func (m *AcceptorRpcGetSummaryRequest) String() string { return proto.CompactTextString(m) }
func (*AcceptorRpcGetSummaryRequest) ProtoMessage()    {}
func (*AcceptorRpcGetSummaryRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb58611707007930, []int{16}
}
func (m *AcceptorRpcGetSummaryRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptorRpcGetSummaryRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptorRpcGetSummaryRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptorRpcGetSummaryRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptorRpcGetSummaryRequest.Merge(m, src)
}
func (m *AcceptorRpcGetSummaryRequest) XXX_Size() int {
	return m.Size()
}
func (m *AcceptorRpcGetSummaryRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptorRpcGetSummaryRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptorRpcGetSummaryRequest proto.InternalMessageInfo

func (m *AcceptorRpcGetSummaryRequest) GetGroupName() string {
	if m != nil {
		return m.GroupName
	}
	return ""
}

func (m *AcceptorRpcGetSummaryRequest) GetProposerID() uint64 {
	if m != nil {
		return m.ProposerID
	}
	return 0
}

func (m *AcceptorRpcGetSummaryRequest) GetAcceptorID() uint64 {
	if m != nil {
		return m.AcceptorID
	}
	return 0
}

func (m *AcceptorRpcGetSummaryRequest) GetOnlyGetTermsContainUnchosenInstFlag() bool {
	if m != nil {
		return m.OnlyGetTermsContainUnchosenInstFlag
	}
	return false
}

func (m *AcceptorRpcGetSummaryRequest) GetGetInstEpochRangeLeftE() uint64 {
	if m != nil {
		return m.GetInstEpochRangeLeftE
	}
	return 0
}

func (m *AcceptorRpcGetSummaryRequest) GetGetInstEpochRangeRightE() uint64 {
	if m != nil {
		return m.GetInstEpochRangeRightE
	}
	return 0
}

type AcceptorRpcGetSummaryResponse struct {
	StatusCode int32                 `protobuf:"varint,1,opt,name=statusCode,proto3" json:"statusCode,omitempty"`
	ErrStr     string                `protobuf:"bytes,2,opt,name=errStr,proto3" json:"errStr,omitempty"`
	Summary    *AcceptorStateSummary `protobuf:"bytes,3,opt,name=summary,proto3" json:"summary,omitempty"`
}

func (m *AcceptorRpcGetSummaryResponse) Reset()         { *m = AcceptorRpcGetSummaryResponse{} }
func (m *AcceptorRpcGetSummaryResponse) String() string { return proto.CompactTextString(m) }
func (*AcceptorRpcGetSummaryResponse) ProtoMessage()    {}
func (*AcceptorRpcGetSummaryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_cb58611707007930, []int{17}
}
func (m *AcceptorRpcGetSummaryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptorRpcGetSummaryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptorRpcGetSummaryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptorRpcGetSummaryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptorRpcGetSummaryResponse.Merge(m, src)
}
func (m *AcceptorRpcGetSummaryResponse) XXX_Size() int {
	return m.Size()
}
func (m *AcceptorRpcGetSummaryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptorRpcGetSummaryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptorRpcGetSummaryResponse proto.InternalMessageInfo

func (m *AcceptorRpcGetSummaryResponse) GetStatusCode() int32 {
	if m != nil {
		return m.StatusCode
	}
	return 0
}

func (m *AcceptorRpcGetSummaryResponse) GetErrStr() string {
	if m != nil {
		return m.ErrStr
	}
	return ""
}

func (m *AcceptorRpcGetSummaryResponse) GetSummary() *AcceptorStateSummary {
	if m != nil {
		return m.Summary
	}
	return nil
}

func init() {
	proto.RegisterEnum("veela.StatusCode", StatusCode_name, StatusCode_value)
	proto.RegisterType((*NetworkAddr)(nil), "veela.NetworkAddr")
	proto.RegisterType((*ElectionResult)(nil), "veela.ElectionResult")
	proto.RegisterType((*AcceptValueMemberIdx)(nil), "veela.AcceptValueMemberIdx")
	proto.RegisterType((*AcceptValueMemberIdxs)(nil), "veela.AcceptValueMemberIdxs")
	proto.RegisterType((*AcceptorInOnePaxosInstanceState)(nil), "veela.AcceptorInOnePaxosInstanceState")
	proto.RegisterMapType((map[uint64]uint64)(nil), "veela.AcceptorInOnePaxosInstanceState.AcceptValueLogdbIdxMapEntry")
	proto.RegisterType((*AcceptorIDMapToNetworkAddr)(nil), "veela.AcceptorIDMapToNetworkAddr")
	proto.RegisterMapType((map[uint64]*NetworkAddr)(nil), "veela.AcceptorIDMapToNetworkAddr.AcceptorIDMapToNetworkAddrEntry")
	proto.RegisterType((*AcceptorTermState)(nil), "veela.AcceptorTermState")
	proto.RegisterType((*AcceptorStateSummary)(nil), "veela.AcceptorStateSummary")
	proto.RegisterType((*AcceptorRpcPrepareRequest)(nil), "veela.AcceptorRpcPrepareRequest")
	proto.RegisterType((*AcceptorRpcPrepareResponese)(nil), "veela.AcceptorRpcPrepareResponese")
	proto.RegisterMapType((map[uint64][]byte)(nil), "veela.AcceptorRpcPrepareResponese.AcceptValueIDMapToAcceptValueBsEntry")
	proto.RegisterType((*AcceptorRpcAcceptRequest)(nil), "veela.AcceptorRpcAcceptRequest")
	proto.RegisterType((*AcceptorRpcAcceptResponse)(nil), "veela.AcceptorRpcAcceptResponse")
	proto.RegisterType((*AcceptorRpcChosenNotifyRequest)(nil), "veela.AcceptorRpcChosenNotifyRequest")
	proto.RegisterType((*AcceptorRpcChosenNotifyResponse)(nil), "veela.AcceptorRpcChosenNotifyResponse")
	proto.RegisterType((*AcceptorRpcGetAcceptValueByIDRequest)(nil), "veela.AcceptorRpcGetAcceptValueByIDRequest")
	proto.RegisterType((*AcceptorRpcGetAcceptValueByIDResponse)(nil), "veela.AcceptorRpcGetAcceptValueByIDResponse")
	proto.RegisterMapType((map[uint64][]byte)(nil), "veela.AcceptorRpcGetAcceptValueByIDResponse.AcceptValueIDMapToAcceptValueBsEntry")
	proto.RegisterType((*AcceptorRpcGetSummaryRequest)(nil), "veela.AcceptorRpcGetSummaryRequest")
	proto.RegisterType((*AcceptorRpcGetSummaryResponse)(nil), "veela.AcceptorRpcGetSummaryResponse")
}

func init() { proto.RegisterFile("veela.proto", fileDescriptor_cb58611707007930) }

var fileDescriptor_cb58611707007930 = []byte{
	// 1289 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0xcd, 0x6f, 0x1b, 0xc5,
	0x1b, 0xce, 0xee, 0xda, 0x4e, 0xfb, 0xba, 0x4d, 0xfd, 0x1b, 0x35, 0xf9, 0x6d, 0x9d, 0xe2, 0x86,
	0x25, 0x54, 0x11, 0x87, 0x22, 0x95, 0x0f, 0x55, 0x48, 0xa0, 0xae, 0xed, 0x6d, 0xb2, 0x22, 0xb6,
	0xc3, 0xc4, 0xe9, 0x35, 0x9a, 0xda, 0x93, 0xd4, 0xaa, 0xbd, 0xb3, 0xcc, 0x8e, 0x4b, 0xdc, 0x1b,
	0xe2, 0xce, 0xc7, 0x0d, 0x89, 0x2b, 0x7f, 0x08, 0x82, 0x0b, 0x48, 0x1c, 0x2a, 0x71, 0xe1, 0x88,
	0xda, 0x13, 0x77, 0xb8, 0xa3, 0x9d, 0x1d, 0xd7, 0xb3, 0xfe, 0x96, 0x82, 0x5a, 0x6e, 0x9e, 0x67,
	0xde, 0x9d, 0x77, 0xde, 0x67, 0x9e, 0xf7, 0x23, 0x81, 0xfc, 0x63, 0x4a, 0xbb, 0xe4, 0x56, 0xc8,
	0x99, 0x60, 0x28, 0x2b, 0x17, 0x4e, 0x0d, 0xf2, 0x75, 0x2a, 0x3e, 0x63, 0xfc, 0x91, 0xdb, 0x6e,
	0x73, 0x54, 0x84, 0x0b, 0x72, 0xbb, 0xc5, 0xba, 0xb6, 0xb1, 0x65, 0xec, 0x5c, 0xc4, 0x2f, 0xd6,
	0x68, 0x0d, 0xcc, 0x4e, 0x68, 0x9b, 0x12, 0x35, 0x3b, 0x21, 0x42, 0x90, 0x09, 0x19, 0x17, 0xb6,
	0xb5, 0x65, 0xec, 0x5c, 0xc6, 0xf2, 0xb7, 0xd3, 0x84, 0x35, 0xaf, 0x4b, 0x5b, 0xa2, 0xc3, 0x02,
	0x4c, 0xa3, 0x7e, 0x57, 0x20, 0x1b, 0x56, 0x05, 0xe5, 0xbd, 0x7d, 0x1a, 0xc8, 0x03, 0xb3, 0x78,
	0xb8, 0x44, 0x3b, 0x70, 0x85, 0xb4, 0x5a, 0x34, 0x14, 0x8c, 0xfb, 0x55, 0x97, 0x73, 0x32, 0xb0,
	0xcd, 0x2d, 0x6b, 0x27, 0x83, 0xc7, 0x61, 0xe7, 0x2e, 0x5c, 0x75, 0x25, 0x74, 0x9f, 0x74, 0xfb,
	0xb4, 0x46, 0x7b, 0x0f, 0x28, 0xf7, 0xdb, 0x67, 0x68, 0x03, 0x72, 0xec, 0xe4, 0x24, 0xa2, 0x42,
	0x1d, 0xad, 0x56, 0xa8, 0x00, 0x56, 0x97, 0x06, 0xf2, 0xaa, 0x59, 0x1c, 0xff, 0x74, 0xf6, 0x60,
	0x7d, 0xda, 0x09, 0x11, 0x7a, 0x1b, 0x32, 0x9d, 0xf6, 0x59, 0x64, 0x1b, 0x5b, 0xd6, 0x4e, 0xfe,
	0xf6, 0xe6, 0xad, 0x84, 0xa2, 0x69, 0xb6, 0x58, 0x1a, 0x3a, 0x7f, 0x99, 0x70, 0xc3, 0x1d, 0xde,
	0x2f, 0x68, 0x04, 0xf4, 0x80, 0x9c, 0xb1, 0xc8, 0x0f, 0x22, 0x41, 0x82, 0x16, 0x3d, 0x14, 0x44,
	0x50, 0x54, 0x02, 0x68, 0x3d, 0x64, 0x11, 0x0d, 0xee, 0x75, 0xc9, 0xa9, 0xbc, 0xdb, 0x05, 0xac,
	0x21, 0xc8, 0x81, 0x4b, 0x21, 0xa7, 0x21, 0xe1, 0xd4, 0x0b, 0x59, 0xeb, 0xa1, 0xbc, 0x68, 0x06,
	0xa7, 0x30, 0xb4, 0x05, 0xf9, 0x84, 0x86, 0xc4, 0xc4, 0x92, 0x26, 0x3a, 0x84, 0xb6, 0xe1, 0x32,
	0x19, 0xdd, 0xd3, 0xaf, 0xda, 0x19, 0x69, 0x93, 0x06, 0xd1, 0x13, 0xd8, 0xd0, 0x80, 0x7d, 0x76,
	0xda, 0x7e, 0xe0, 0xb7, 0xcf, 0x6a, 0x24, 0xb4, 0xb3, 0x32, 0xe4, 0x72, 0x2a, 0xe4, 0x99, 0x31,
	0xe9, 0x94, 0x68, 0x87, 0x78, 0x81, 0xe0, 0x03, 0x3c, 0xc3, 0x43, 0xd1, 0x87, 0xcd, 0x39, 0x9f,
	0xc5, 0xcf, 0xf4, 0x88, 0x0e, 0x24, 0x3f, 0x19, 0x1c, 0xff, 0x44, 0x57, 0x21, 0xfb, 0x38, 0x36,
	0x55, 0x8c, 0x24, 0x8b, 0x0f, 0xcc, 0x3b, 0x86, 0xf3, 0x85, 0x09, 0xc5, 0x17, 0x57, 0xac, 0xd6,
	0x48, 0xd8, 0x64, 0xba, 0x6e, 0x3f, 0x37, 0xa0, 0x48, 0x66, 0x6e, 0xab, 0xd7, 0x75, 0xc7, 0x43,
	0x9d, 0x30, 0x9c, 0xb3, 0x95, 0x44, 0x3a, 0xc7, 0x49, 0x91, 0x68, 0xc2, 0x98, 0xfe, 0xf9, 0x94,
	0x88, 0x77, 0xf4, 0x88, 0xf3, 0xb7, 0x91, 0xba, 0xa2, 0xf6, 0xa5, 0xce, 0xc2, 0x2f, 0x16, 0xfc,
	0x6f, 0xe8, 0xa3, 0x49, 0x79, 0x2f, 0x91, 0xdb, 0x4d, 0x58, 0x8b, 0x04, 0xe1, 0xe2, 0x1e, 0x67,
	0xbd, 0xf8, 0xd1, 0x3c, 0xe5, 0x60, 0x0c, 0x45, 0x1f, 0xc2, 0x1a, 0x4d, 0x25, 0xa7, 0x72, 0xba,
	0xae, 0x9c, 0xa6, 0x33, 0x17, 0x8f, 0x19, 0x23, 0x32, 0x97, 0x62, 0x4b, 0x1e, 0xf5, 0xfa, 0x42,
	0x8a, 0xe7, 0x51, 0x28, 0x25, 0xdd, 0xed, 0x56, 0x46, 0xb9, 0x93, 0x91, 0xb9, 0x93, 0x06, 0xd1,
	0x13, 0xd8, 0x26, 0xf3, 0xd5, 0x9a, 0x54, 0x93, 0x44, 0xe0, 0x37, 0x97, 0x13, 0x38, 0x5e, 0xea,
	0x4c, 0xb4, 0x07, 0x37, 0xba, 0x4a, 0xc7, 0x8d, 0x93, 0x7d, 0x12, 0x89, 0x89, 0xe7, 0xb0, 0x73,
	0x92, 0xfc, 0x45, 0x66, 0xce, 0xb7, 0xe6, 0xb0, 0xaa, 0x31, 0x2e, 0x91, 0xc3, 0x7e, 0xaf, 0x47,
	0xf8, 0x00, 0xbd, 0x0b, 0xeb, 0x6d, 0xda, 0xa5, 0x82, 0xc6, 0xee, 0xcb, 0xf4, 0x84, 0x0d, 0xcb,
	0x44, 0xf2, 0xaa, 0xd3, 0x37, 0xd1, 0x47, 0x50, 0x6c, 0xf5, 0x39, 0xa7, 0x81, 0x90, 0x8f, 0x1d,
	0x63, 0x98, 0x04, 0xa7, 0x74, 0x9f, 0x9e, 0x08, 0x4f, 0xe5, 0xd3, 0x1c, 0x0b, 0x74, 0x17, 0x36,
	0xa7, 0xee, 0xe2, 0xce, 0xe9, 0x43, 0xe1, 0xa9, 0xfa, 0x33, 0xcf, 0x04, 0xed, 0x01, 0x22, 0xe3,
	0x51, 0x46, 0x76, 0x46, 0x3e, 0x82, 0x3d, 0xf6, 0x08, 0x2f, 0x0c, 0xf0, 0x94, 0x6f, 0x9c, 0xbf,
	0x0d, 0xb8, 0x36, 0xb4, 0xc4, 0x61, 0xeb, 0x20, 0xa9, 0x8b, 0x98, 0x7e, 0xda, 0xa7, 0x91, 0x40,
	0xd7, 0xe1, 0xe2, 0x29, 0x67, 0xfd, 0xb0, 0x4e, 0x7a, 0x54, 0x35, 0xa9, 0x11, 0x10, 0xd7, 0xde,
	0x90, 0xb3, 0x90, 0x45, 0x94, 0xfb, 0x55, 0x15, 0xb7, 0x86, 0xc4, 0xfb, 0x23, 0x01, 0xaa, 0xb0,
	0x34, 0x24, 0x2e, 0x41, 0x1d, 0x99, 0x43, 0x49, 0x35, 0x4d, 0x16, 0x13, 0x15, 0x3b, 0x3b, 0xa5,
	0x62, 0xdf, 0x85, 0x4d, 0x16, 0x74, 0x07, 0x98, 0x8a, 0x3e, 0xa7, 0xae, 0x5e, 0x84, 0xa5, 0x94,
	0x73, 0x52, 0xca, 0xf3, 0x4c, 0x9c, 0xdf, 0xac, 0x61, 0xc1, 0x4c, 0xc7, 0x1d, 0x85, 0x2c, 0xa0,
	0x91, 0x8c, 0x2d, 0x12, 0x44, 0xf4, 0xa3, 0x0a, 0x6b, 0x53, 0xd5, 0xf3, 0x34, 0x24, 0xee, 0x87,
	0x94, 0xf3, 0x43, 0xc1, 0x55, 0x97, 0x56, 0xab, 0xe4, 0xf6, 0xac, 0xd7, 0x89, 0x68, 0x5b, 0x5e,
	0xc5, 0x92, 0x57, 0x49, 0x61, 0x28, 0x84, 0x1b, 0x0b, 0x12, 0x40, 0x32, 0xb2, 0x7c, 0x3e, 0x2d,
	0x3a, 0x0e, 0x7d, 0x63, 0x0c, 0x5d, 0x2a, 0x0e, 0x64, 0x39, 0xd0, 0x58, 0x29, 0x47, 0x2a, 0x85,
	0x77, 0xc7, 0x5c, 0x4e, 0xe1, 0xe6, 0x96, 0x3b, 0xff, 0xa4, 0xa4, 0x7c, 0x2f, 0xf2, 0x57, 0xc4,
	0xb0, 0xbd, 0xcc, 0x41, 0x8b, 0x5a, 0xd7, 0x25, 0xbd, 0x68, 0xff, 0x6a, 0x82, 0xad, 0xdd, 0x3c,
	0xf9, 0xf9, 0x2a, 0xc5, 0xbc, 0x0d, 0x97, 0x95, 0x70, 0xdb, 0xba, 0x9a, 0xd3, 0x60, 0x3c, 0x9e,
	0x09, 0x96, 0x22, 0x43, 0x55, 0xb6, 0x71, 0x18, 0x95, 0xe1, 0x7a, 0xac, 0xea, 0x0a, 0x0b, 0x04,
	0xe9, 0x04, 0x93, 0xca, 0x5f, 0x95, 0x72, 0x9b, 0x6b, 0x33, 0xe1, 0xad, 0x1c, 0xd9, 0x17, 0x24,
	0x91, 0xe3, 0xb0, 0xf3, 0x67, 0xba, 0x38, 0x0c, 0xe9, 0x8c, 0x75, 0x70, 0xbe, 0x14, 0x49, 0x78,
	0x4b, 0xa7, 0x88, 0x8e, 0xbd, 0xfc, 0x14, 0x71, 0xbe, 0x37, 0xa1, 0xa4, 0xc5, 0x9a, 0xf4, 0xc0,
	0x3a, 0x13, 0x9d, 0x93, 0xc1, 0x2b, 0x16, 0x50, 0x7a, 0xf2, 0xcc, 0x4e, 0x9b, 0x3c, 0x17, 0xc9,
	0x22, 0xb7, 0x84, 0x2c, 0xd2, 0x9e, 0xca, 0x91, 0xd4, 0x52, 0xda, 0x53, 0x39, 0x72, 0x06, 0xa3,
	0xc9, 0x6b, 0x82, 0xa5, 0x73, 0xea, 0x22, 0x3d, 0xca, 0x5b, 0xe3, 0xa3, 0xbc, 0xf3, 0xa3, 0x31,
	0xac, 0x18, 0xd2, 0xf7, 0x2e, 0x15, 0xba, 0x5a, 0x07, 0x7e, 0xf5, 0x55, 0xbe, 0xd3, 0x4d, 0x58,
	0x4b, 0x3d, 0x49, 0x52, 0x4f, 0x33, 0x78, 0x0c, 0x75, 0x7e, 0xb2, 0xe0, 0xcd, 0x05, 0x41, 0x9c,
	0x93, 0xc6, 0x25, 0x52, 0xc7, 0xfa, 0x77, 0xbb, 0xcb, 0x77, 0x4b, 0x74, 0x97, 0x64, 0x36, 0xf9,
	0x64, 0xb2, 0xbb, 0xcc, 0x66, 0xe0, 0x3f, 0xdc, 0x67, 0x7e, 0x30, 0xe1, 0x7a, 0x3a, 0x06, 0x35,
	0x51, 0xbe, 0x1c, 0x09, 0x1e, 0xc0, 0x1b, 0x71, 0x2a, 0xef, 0x52, 0x11, 0x4f, 0x72, 0x91, 0x4a,
	0xe9, 0xa3, 0x20, 0x49, 0x96, 0xf8, 0x71, 0xb4, 0x89, 0x7e, 0x19, 0x53, 0xf4, 0x3e, 0x6c, 0x9c,
	0xd2, 0xa9, 0xe3, 0x6c, 0x52, 0x6f, 0x66, 0xec, 0xa2, 0x3b, 0xf0, 0xff, 0x89, 0x1d, 0x35, 0xc6,
	0x26, 0x1d, 0x6c, 0xd6, 0xb6, 0xf3, 0xa5, 0x01, 0xaf, 0xcd, 0xa0, 0xf0, 0x9c, 0x09, 0xf0, 0x1e,
	0xac, 0x46, 0xc9, 0x51, 0x4a, 0xe8, 0x9b, 0x63, 0xaa, 0xd3, 0xff, 0x04, 0xc0, 0x43, 0xdb, 0xb7,
	0xbe, 0x32, 0x00, 0x0e, 0x47, 0xa7, 0xe7, 0xc0, 0x6c, 0x7c, 0x5c, 0x58, 0x41, 0x57, 0x20, 0x7f,
	0x54, 0x3f, 0x3c, 0xf0, 0x2a, 0xfe, 0x3d, 0xdf, 0xab, 0x16, 0x0c, 0x94, 0x87, 0xd5, 0xa6, 0x5f,
	0xf3, 0x1a, 0x47, 0xcd, 0x82, 0x89, 0xae, 0xc1, 0xfa, 0x2e, 0x6e, 0x1c, 0x1d, 0x1c, 0xd7, 0xdd,
	0x9a, 0x77, 0x5c, 0x6d, 0xd4, 0x9b, 0xc7, 0x35, 0xb7, 0x59, 0xd9, 0x2b, 0x58, 0xa8, 0x08, 0x1b,
	0x6e, 0xa5, 0xe2, 0x1d, 0x34, 0x1b, 0xf8, 0xd8, 0xaf, 0xea, 0x7b, 0x19, 0x04, 0x90, 0xf3, 0xdc,
	0x5d, 0xd7, 0xaf, 0x17, 0xb2, 0xc8, 0x86, 0xab, 0xd8, 0x3b, 0x6c, 0x1c, 0xe1, 0x8a, 0x77, 0x7c,
	0x54, 0x77, 0xef, 0xbb, 0xfe, 0xbe, 0x5b, 0xde, 0xf7, 0x0a, 0xb9, 0xb2, 0xfd, 0xf3, 0xb3, 0x92,
	0xf1, 0xf4, 0x59, 0xc9, 0xf8, 0xe3, 0x59, 0xc9, 0xf8, 0xfa, 0x79, 0x69, 0xe5, 0xe9, 0xf3, 0xd2,
	0xca, 0xef, 0xcf, 0x4b, 0x2b, 0x0f, 0x72, 0xf2, 0x3f, 0x45, 0xef, 0xfc, 0x13, 0x00, 0x00, 0xff,
	0xff, 0x9b, 0xf6, 0x94, 0xef, 0x67, 0x12, 0x00, 0x00,
}

func (m *NetworkAddr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NetworkAddr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NetworkAddr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Port != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintVeela(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Protocol) > 0 {
		i -= len(m.Protocol)
		copy(dAtA[i:], m.Protocol)
		i = encodeVarintVeela(dAtA, i, uint64(len(m.Protocol)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ElectionResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ElectionResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ElectionResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AcceptorIDArray) > 0 {
		dAtA2 := make([]byte, len(m.AcceptorIDArray)*10)
		var j1 int
		for _, num := range m.AcceptorIDArray {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintVeela(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0x12
	}
	if m.TermLen != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.TermLen))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AcceptValueMemberIdx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptValueMemberIdx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptValueMemberIdx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Len != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.Len))
		i--
		dAtA[i] = 0x10
	}
	if m.Offset != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AcceptValueMemberIdxs) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptValueMemberIdxs) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptValueMemberIdxs) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Idxs) > 0 {
		for iNdEx := len(m.Idxs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Idxs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVeela(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AcceptorInOnePaxosInstanceState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptorInOnePaxosInstanceState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptorInOnePaxosInstanceState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AcceptValueLogdbIdxMap) > 0 {
		for k := range m.AcceptValueLogdbIdxMap {
			v := m.AcceptValueLogdbIdxMap[k]
			baseI := i
			i = encodeVarintVeela(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i = encodeVarintVeela(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintVeela(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.AcceptValueID != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.AcceptValueID))
		i--
		dAtA[i] = 0x20
	}
	if m.AcceptEpoch != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.AcceptEpoch))
		i--
		dAtA[i] = 0x18
	}
	if m.PrepareEpoch != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.PrepareEpoch))
		i--
		dAtA[i] = 0x10
	}
	if m.ChosenFlag {
		i--
		if m.ChosenFlag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AcceptorIDMapToNetworkAddr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptorIDMapToNetworkAddr) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptorIDMapToNetworkAddr) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AcceptorIDMapToNetworkAddr) > 0 {
		for k := range m.AcceptorIDMapToNetworkAddr {
			v := m.AcceptorIDMapToNetworkAddr[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintVeela(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintVeela(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintVeela(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AcceptorTermState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptorTermState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptorTermState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LogdbIdxOfLastAcceptorTermState != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.LogdbIdxOfLastAcceptorTermState))
		i--
		dAtA[i] = 0x30
	}
	if len(m.AcceptorInOnePaxosInstanceStateArray) > 0 {
		for iNdEx := len(m.AcceptorInOnePaxosInstanceStateArray) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AcceptorInOnePaxosInstanceStateArray[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVeela(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.AllChosenFlag {
		i--
		if m.AllChosenFlag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.AcceptorIDMapToNetworkAddr != nil {
		{
			size, err := m.AcceptorIDMapToNetworkAddr.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVeela(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ElectionResult != nil {
		{
			size, err := m.ElectionResult.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVeela(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.StartFromInstE != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.StartFromInstE))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AcceptorStateSummary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptorStateSummary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptorStateSummary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AcceptorTermStates) > 0 {
		for iNdEx := len(m.AcceptorTermStates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AcceptorTermStates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintVeela(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.CurrentInstEpochRangeRightE != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.CurrentInstEpochRangeRightE))
		i--
		dAtA[i] = 0x18
	}
	if m.CurrentInstEpochRangeLeftE != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.CurrentInstEpochRangeLeftE))
		i--
		dAtA[i] = 0x10
	}
	if m.DeleteInstBeforeEpoch != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.DeleteInstBeforeEpoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AcceptorRpcPrepareRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptorRpcPrepareRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptorRpcPrepareRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OnlyRetureAcceptValueIDFlag {
		i--
		if m.OnlyRetureAcceptValueIDFlag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.PrepareEpoch != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.PrepareEpoch))
		i--
		dAtA[i] = 0x28
	}
	if m.InstE != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.InstE))
		i--
		dAtA[i] = 0x20
	}
	if m.AcceptorID != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.AcceptorID))
		i--
		dAtA[i] = 0x18
	}
	if m.ProposerID != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.ProposerID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.GroupName) > 0 {
		i -= len(m.GroupName)
		copy(dAtA[i:], m.GroupName)
		i = encodeVarintVeela(dAtA, i, uint64(len(m.GroupName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AcceptorRpcPrepareResponese) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptorRpcPrepareResponese) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptorRpcPrepareResponese) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AcceptValueIDMapToAcceptValueBs) > 0 {
		for k := range m.AcceptValueIDMapToAcceptValueBs {
			v := m.AcceptValueIDMapToAcceptValueBs[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintVeela(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintVeela(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintVeela(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.AcceptorInOnePaxosInstanceState != nil {
		{
			size, err := m.AcceptorInOnePaxosInstanceState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVeela(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.PromisedFlag {
		i--
		if m.PromisedFlag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ErrStr) > 0 {
		i -= len(m.ErrStr)
		copy(dAtA[i:], m.ErrStr)
		i = encodeVarintVeela(dAtA, i, uint64(len(m.ErrStr)))
		i--
		dAtA[i] = 0x12
	}
	if m.StatusCode != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AcceptorRpcAcceptRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptorRpcAcceptRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptorRpcAcceptRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ToAcceptValueBs) > 0 {
		i -= len(m.ToAcceptValueBs)
		copy(dAtA[i:], m.ToAcceptValueBs)
		i = encodeVarintVeela(dAtA, i, uint64(len(m.ToAcceptValueBs)))
		i--
		dAtA[i] = 0x42
	}
	if m.OnlyContainAcceptValueIDFlag {
		i--
		if m.OnlyContainAcceptValueIDFlag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.ToAcceptValueID != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.ToAcceptValueID))
		i--
		dAtA[i] = 0x30
	}
	if m.PreparedEpoch != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.PreparedEpoch))
		i--
		dAtA[i] = 0x28
	}
	if m.InstE != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.InstE))
		i--
		dAtA[i] = 0x20
	}
	if m.AcceptorID != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.AcceptorID))
		i--
		dAtA[i] = 0x18
	}
	if m.ProposerID != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.ProposerID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.GroupName) > 0 {
		i -= len(m.GroupName)
		copy(dAtA[i:], m.GroupName)
		i = encodeVarintVeela(dAtA, i, uint64(len(m.GroupName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AcceptorRpcAcceptResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptorRpcAcceptResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptorRpcAcceptResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AcceptorInOnePaxosInstanceState != nil {
		{
			size, err := m.AcceptorInOnePaxosInstanceState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVeela(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.AcceptedFlag {
		i--
		if m.AcceptedFlag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ErrStr) > 0 {
		i -= len(m.ErrStr)
		copy(dAtA[i:], m.ErrStr)
		i = encodeVarintVeela(dAtA, i, uint64(len(m.ErrStr)))
		i--
		dAtA[i] = 0x12
	}
	if m.StatusCode != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AcceptorRpcChosenNotifyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptorRpcChosenNotifyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptorRpcChosenNotifyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AcceptValueBs != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.AcceptValueBs))
		i--
		dAtA[i] = 0x38
	}
	if m.OnlyContainAcceptValueIDFlag {
		i--
		if m.OnlyContainAcceptValueIDFlag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.AcceptValueID != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.AcceptValueID))
		i--
		dAtA[i] = 0x28
	}
	if m.InstE != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.InstE))
		i--
		dAtA[i] = 0x20
	}
	if m.AcceptorID != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.AcceptorID))
		i--
		dAtA[i] = 0x18
	}
	if m.ProposerID != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.ProposerID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.GroupName) > 0 {
		i -= len(m.GroupName)
		copy(dAtA[i:], m.GroupName)
		i = encodeVarintVeela(dAtA, i, uint64(len(m.GroupName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AcceptorRpcChosenNotifyResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptorRpcChosenNotifyResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptorRpcChosenNotifyResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChosenFlag {
		i--
		if m.ChosenFlag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.ErrStr) > 0 {
		i -= len(m.ErrStr)
		copy(dAtA[i:], m.ErrStr)
		i = encodeVarintVeela(dAtA, i, uint64(len(m.ErrStr)))
		i--
		dAtA[i] = 0x12
	}
	if m.StatusCode != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AcceptorRpcGetAcceptValueByIDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptorRpcGetAcceptValueByIDRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptorRpcGetAcceptValueByIDRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AcceptValueIDs) > 0 {
		dAtA9 := make([]byte, len(m.AcceptValueIDs)*10)
		var j8 int
		for _, num := range m.AcceptValueIDs {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintVeela(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x2a
	}
	if m.InstE != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.InstE))
		i--
		dAtA[i] = 0x20
	}
	if m.AcceptorID != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.AcceptorID))
		i--
		dAtA[i] = 0x18
	}
	if m.ProposerID != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.ProposerID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.GroupName) > 0 {
		i -= len(m.GroupName)
		copy(dAtA[i:], m.GroupName)
		i = encodeVarintVeela(dAtA, i, uint64(len(m.GroupName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AcceptorRpcGetAcceptValueByIDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptorRpcGetAcceptValueByIDResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptorRpcGetAcceptValueByIDResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AcceptValueIDMapToAcceptValueBs) > 0 {
		for k := range m.AcceptValueIDMapToAcceptValueBs {
			v := m.AcceptValueIDMapToAcceptValueBs[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintVeela(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintVeela(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintVeela(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.AcceptorInOnePaxosInstanceState != nil {
		{
			size, err := m.AcceptorInOnePaxosInstanceState.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVeela(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ErrStr) > 0 {
		i -= len(m.ErrStr)
		copy(dAtA[i:], m.ErrStr)
		i = encodeVarintVeela(dAtA, i, uint64(len(m.ErrStr)))
		i--
		dAtA[i] = 0x12
	}
	if m.StatusCode != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AcceptorRpcGetSummaryRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptorRpcGetSummaryRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptorRpcGetSummaryRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GetInstEpochRangeRightE != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.GetInstEpochRangeRightE))
		i--
		dAtA[i] = 0x30
	}
	if m.GetInstEpochRangeLeftE != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.GetInstEpochRangeLeftE))
		i--
		dAtA[i] = 0x28
	}
	if m.OnlyGetTermsContainUnchosenInstFlag {
		i--
		if m.OnlyGetTermsContainUnchosenInstFlag {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.AcceptorID != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.AcceptorID))
		i--
		dAtA[i] = 0x18
	}
	if m.ProposerID != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.ProposerID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.GroupName) > 0 {
		i -= len(m.GroupName)
		copy(dAtA[i:], m.GroupName)
		i = encodeVarintVeela(dAtA, i, uint64(len(m.GroupName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AcceptorRpcGetSummaryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptorRpcGetSummaryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptorRpcGetSummaryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Summary != nil {
		{
			size, err := m.Summary.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintVeela(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ErrStr) > 0 {
		i -= len(m.ErrStr)
		copy(dAtA[i:], m.ErrStr)
		i = encodeVarintVeela(dAtA, i, uint64(len(m.ErrStr)))
		i--
		dAtA[i] = 0x12
	}
	if m.StatusCode != 0 {
		i = encodeVarintVeela(dAtA, i, uint64(m.StatusCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintVeela(dAtA []byte, offset int, v uint64) int {
	offset -= sovVeela(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NetworkAddr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Protocol)
	if l > 0 {
		n += 1 + l + sovVeela(uint64(l))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovVeela(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovVeela(uint64(m.Port))
	}
	return n
}

func (m *ElectionResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TermLen != 0 {
		n += 1 + sovVeela(uint64(m.TermLen))
	}
	if len(m.AcceptorIDArray) > 0 {
		l = 0
		for _, e := range m.AcceptorIDArray {
			l += sovVeela(uint64(e))
		}
		n += 1 + sovVeela(uint64(l)) + l
	}
	return n
}

func (m *AcceptValueMemberIdx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Offset != 0 {
		n += 1 + sovVeela(uint64(m.Offset))
	}
	if m.Len != 0 {
		n += 1 + sovVeela(uint64(m.Len))
	}
	return n
}

func (m *AcceptValueMemberIdxs) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Idxs) > 0 {
		for _, e := range m.Idxs {
			l = e.Size()
			n += 1 + l + sovVeela(uint64(l))
		}
	}
	return n
}

func (m *AcceptorInOnePaxosInstanceState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChosenFlag {
		n += 2
	}
	if m.PrepareEpoch != 0 {
		n += 1 + sovVeela(uint64(m.PrepareEpoch))
	}
	if m.AcceptEpoch != 0 {
		n += 1 + sovVeela(uint64(m.AcceptEpoch))
	}
	if m.AcceptValueID != 0 {
		n += 1 + sovVeela(uint64(m.AcceptValueID))
	}
	if len(m.AcceptValueLogdbIdxMap) > 0 {
		for k, v := range m.AcceptValueLogdbIdxMap {
			_ = k
			_ = v
			mapEntrySize := 1 + sovVeela(uint64(k)) + 1 + sovVeela(uint64(v))
			n += mapEntrySize + 1 + sovVeela(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AcceptorIDMapToNetworkAddr) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AcceptorIDMapToNetworkAddr) > 0 {
		for k, v := range m.AcceptorIDMapToNetworkAddr {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovVeela(uint64(l))
			}
			mapEntrySize := 1 + sovVeela(uint64(k)) + l
			n += mapEntrySize + 1 + sovVeela(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AcceptorTermState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StartFromInstE != 0 {
		n += 1 + sovVeela(uint64(m.StartFromInstE))
	}
	if m.ElectionResult != nil {
		l = m.ElectionResult.Size()
		n += 1 + l + sovVeela(uint64(l))
	}
	if m.AcceptorIDMapToNetworkAddr != nil {
		l = m.AcceptorIDMapToNetworkAddr.Size()
		n += 1 + l + sovVeela(uint64(l))
	}
	if m.AllChosenFlag {
		n += 2
	}
	if len(m.AcceptorInOnePaxosInstanceStateArray) > 0 {
		for _, e := range m.AcceptorInOnePaxosInstanceStateArray {
			l = e.Size()
			n += 1 + l + sovVeela(uint64(l))
		}
	}
	if m.LogdbIdxOfLastAcceptorTermState != 0 {
		n += 1 + sovVeela(uint64(m.LogdbIdxOfLastAcceptorTermState))
	}
	return n
}

func (m *AcceptorStateSummary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DeleteInstBeforeEpoch != 0 {
		n += 1 + sovVeela(uint64(m.DeleteInstBeforeEpoch))
	}
	if m.CurrentInstEpochRangeLeftE != 0 {
		n += 1 + sovVeela(uint64(m.CurrentInstEpochRangeLeftE))
	}
	if m.CurrentInstEpochRangeRightE != 0 {
		n += 1 + sovVeela(uint64(m.CurrentInstEpochRangeRightE))
	}
	if len(m.AcceptorTermStates) > 0 {
		for _, e := range m.AcceptorTermStates {
			l = e.Size()
			n += 1 + l + sovVeela(uint64(l))
		}
	}
	return n
}

func (m *AcceptorRpcPrepareRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GroupName)
	if l > 0 {
		n += 1 + l + sovVeela(uint64(l))
	}
	if m.ProposerID != 0 {
		n += 1 + sovVeela(uint64(m.ProposerID))
	}
	if m.AcceptorID != 0 {
		n += 1 + sovVeela(uint64(m.AcceptorID))
	}
	if m.InstE != 0 {
		n += 1 + sovVeela(uint64(m.InstE))
	}
	if m.PrepareEpoch != 0 {
		n += 1 + sovVeela(uint64(m.PrepareEpoch))
	}
	if m.OnlyRetureAcceptValueIDFlag {
		n += 2
	}
	return n
}

func (m *AcceptorRpcPrepareResponese) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StatusCode != 0 {
		n += 1 + sovVeela(uint64(m.StatusCode))
	}
	l = len(m.ErrStr)
	if l > 0 {
		n += 1 + l + sovVeela(uint64(l))
	}
	if m.PromisedFlag {
		n += 2
	}
	if m.AcceptorInOnePaxosInstanceState != nil {
		l = m.AcceptorInOnePaxosInstanceState.Size()
		n += 1 + l + sovVeela(uint64(l))
	}
	if len(m.AcceptValueIDMapToAcceptValueBs) > 0 {
		for k, v := range m.AcceptValueIDMapToAcceptValueBs {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovVeela(uint64(len(v)))
			}
			mapEntrySize := 1 + sovVeela(uint64(k)) + l
			n += mapEntrySize + 1 + sovVeela(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AcceptorRpcAcceptRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GroupName)
	if l > 0 {
		n += 1 + l + sovVeela(uint64(l))
	}
	if m.ProposerID != 0 {
		n += 1 + sovVeela(uint64(m.ProposerID))
	}
	if m.AcceptorID != 0 {
		n += 1 + sovVeela(uint64(m.AcceptorID))
	}
	if m.InstE != 0 {
		n += 1 + sovVeela(uint64(m.InstE))
	}
	if m.PreparedEpoch != 0 {
		n += 1 + sovVeela(uint64(m.PreparedEpoch))
	}
	if m.ToAcceptValueID != 0 {
		n += 1 + sovVeela(uint64(m.ToAcceptValueID))
	}
	if m.OnlyContainAcceptValueIDFlag {
		n += 2
	}
	l = len(m.ToAcceptValueBs)
	if l > 0 {
		n += 1 + l + sovVeela(uint64(l))
	}
	return n
}

func (m *AcceptorRpcAcceptResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StatusCode != 0 {
		n += 1 + sovVeela(uint64(m.StatusCode))
	}
	l = len(m.ErrStr)
	if l > 0 {
		n += 1 + l + sovVeela(uint64(l))
	}
	if m.AcceptedFlag {
		n += 2
	}
	if m.AcceptorInOnePaxosInstanceState != nil {
		l = m.AcceptorInOnePaxosInstanceState.Size()
		n += 1 + l + sovVeela(uint64(l))
	}
	return n
}

func (m *AcceptorRpcChosenNotifyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GroupName)
	if l > 0 {
		n += 1 + l + sovVeela(uint64(l))
	}
	if m.ProposerID != 0 {
		n += 1 + sovVeela(uint64(m.ProposerID))
	}
	if m.AcceptorID != 0 {
		n += 1 + sovVeela(uint64(m.AcceptorID))
	}
	if m.InstE != 0 {
		n += 1 + sovVeela(uint64(m.InstE))
	}
	if m.AcceptValueID != 0 {
		n += 1 + sovVeela(uint64(m.AcceptValueID))
	}
	if m.OnlyContainAcceptValueIDFlag {
		n += 2
	}
	if m.AcceptValueBs != 0 {
		n += 1 + sovVeela(uint64(m.AcceptValueBs))
	}
	return n
}

func (m *AcceptorRpcChosenNotifyResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StatusCode != 0 {
		n += 1 + sovVeela(uint64(m.StatusCode))
	}
	l = len(m.ErrStr)
	if l > 0 {
		n += 1 + l + sovVeela(uint64(l))
	}
	if m.ChosenFlag {
		n += 2
	}
	return n
}

func (m *AcceptorRpcGetAcceptValueByIDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GroupName)
	if l > 0 {
		n += 1 + l + sovVeela(uint64(l))
	}
	if m.ProposerID != 0 {
		n += 1 + sovVeela(uint64(m.ProposerID))
	}
	if m.AcceptorID != 0 {
		n += 1 + sovVeela(uint64(m.AcceptorID))
	}
	if m.InstE != 0 {
		n += 1 + sovVeela(uint64(m.InstE))
	}
	if len(m.AcceptValueIDs) > 0 {
		l = 0
		for _, e := range m.AcceptValueIDs {
			l += sovVeela(uint64(e))
		}
		n += 1 + sovVeela(uint64(l)) + l
	}
	return n
}

func (m *AcceptorRpcGetAcceptValueByIDResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StatusCode != 0 {
		n += 1 + sovVeela(uint64(m.StatusCode))
	}
	l = len(m.ErrStr)
	if l > 0 {
		n += 1 + l + sovVeela(uint64(l))
	}
	if m.AcceptorInOnePaxosInstanceState != nil {
		l = m.AcceptorInOnePaxosInstanceState.Size()
		n += 1 + l + sovVeela(uint64(l))
	}
	if len(m.AcceptValueIDMapToAcceptValueBs) > 0 {
		for k, v := range m.AcceptValueIDMapToAcceptValueBs {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovVeela(uint64(len(v)))
			}
			mapEntrySize := 1 + sovVeela(uint64(k)) + l
			n += mapEntrySize + 1 + sovVeela(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AcceptorRpcGetSummaryRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GroupName)
	if l > 0 {
		n += 1 + l + sovVeela(uint64(l))
	}
	if m.ProposerID != 0 {
		n += 1 + sovVeela(uint64(m.ProposerID))
	}
	if m.AcceptorID != 0 {
		n += 1 + sovVeela(uint64(m.AcceptorID))
	}
	if m.OnlyGetTermsContainUnchosenInstFlag {
		n += 2
	}
	if m.GetInstEpochRangeLeftE != 0 {
		n += 1 + sovVeela(uint64(m.GetInstEpochRangeLeftE))
	}
	if m.GetInstEpochRangeRightE != 0 {
		n += 1 + sovVeela(uint64(m.GetInstEpochRangeRightE))
	}
	return n
}

func (m *AcceptorRpcGetSummaryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StatusCode != 0 {
		n += 1 + sovVeela(uint64(m.StatusCode))
	}
	l = len(m.ErrStr)
	if l > 0 {
		n += 1 + l + sovVeela(uint64(l))
	}
	if m.Summary != nil {
		l = m.Summary.Size()
		n += 1 + l + sovVeela(uint64(l))
	}
	return n
}

func sovVeela(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozVeela(x uint64) (n int) {
	return sovVeela(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NetworkAddr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVeela
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NetworkAddr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NetworkAddr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Protocol = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVeela(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVeela
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ElectionResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVeela
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ElectionResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ElectionResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TermLen", wireType)
			}
			m.TermLen = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TermLen |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVeela
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AcceptorIDArray = append(m.AcceptorIDArray, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVeela
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVeela
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthVeela
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AcceptorIDArray) == 0 {
					m.AcceptorIDArray = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVeela
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AcceptorIDArray = append(m.AcceptorIDArray, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptorIDArray", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVeela(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVeela
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptValueMemberIdx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVeela
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptValueMemberIdx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptValueMemberIdx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Len", wireType)
			}
			m.Len = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Len |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVeela(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVeela
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptValueMemberIdxs) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVeela
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptValueMemberIdxs: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptValueMemberIdxs: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Idxs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Idxs = append(m.Idxs, &AcceptValueMemberIdx{})
			if err := m.Idxs[len(m.Idxs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVeela(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVeela
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptorInOnePaxosInstanceState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVeela
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptorInOnePaxosInstanceState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptorInOnePaxosInstanceState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChosenFlag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChosenFlag = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareEpoch", wireType)
			}
			m.PrepareEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrepareEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptEpoch", wireType)
			}
			m.AcceptEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcceptEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptValueID", wireType)
			}
			m.AcceptValueID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcceptValueID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptValueLogdbIdxMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AcceptValueLogdbIdxMap == nil {
				m.AcceptValueLogdbIdxMap = make(map[uint64]uint64)
			}
			var mapkey uint64
			var mapvalue uint64
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVeela
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVeela
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVeela
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipVeela(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthVeela
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AcceptValueLogdbIdxMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVeela(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVeela
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptorIDMapToNetworkAddr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVeela
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptorIDMapToNetworkAddr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptorIDMapToNetworkAddr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptorIDMapToNetworkAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AcceptorIDMapToNetworkAddr == nil {
				m.AcceptorIDMapToNetworkAddr = make(map[uint64]*NetworkAddr)
			}
			var mapkey uint64
			var mapvalue *NetworkAddr
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVeela
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVeela
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVeela
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthVeela
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthVeela
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &NetworkAddr{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipVeela(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthVeela
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AcceptorIDMapToNetworkAddr[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVeela(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVeela
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptorTermState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVeela
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptorTermState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptorTermState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartFromInstE", wireType)
			}
			m.StartFromInstE = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartFromInstE |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ElectionResult", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ElectionResult == nil {
				m.ElectionResult = &ElectionResult{}
			}
			if err := m.ElectionResult.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptorIDMapToNetworkAddr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AcceptorIDMapToNetworkAddr == nil {
				m.AcceptorIDMapToNetworkAddr = &AcceptorIDMapToNetworkAddr{}
			}
			if err := m.AcceptorIDMapToNetworkAddr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllChosenFlag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllChosenFlag = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptorInOnePaxosInstanceStateArray", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AcceptorInOnePaxosInstanceStateArray = append(m.AcceptorInOnePaxosInstanceStateArray, &AcceptorInOnePaxosInstanceState{})
			if err := m.AcceptorInOnePaxosInstanceStateArray[len(m.AcceptorInOnePaxosInstanceStateArray)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogdbIdxOfLastAcceptorTermState", wireType)
			}
			m.LogdbIdxOfLastAcceptorTermState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogdbIdxOfLastAcceptorTermState |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVeela(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVeela
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptorStateSummary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVeela
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptorStateSummary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptorStateSummary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteInstBeforeEpoch", wireType)
			}
			m.DeleteInstBeforeEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeleteInstBeforeEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentInstEpochRangeLeftE", wireType)
			}
			m.CurrentInstEpochRangeLeftE = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentInstEpochRangeLeftE |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentInstEpochRangeRightE", wireType)
			}
			m.CurrentInstEpochRangeRightE = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentInstEpochRangeRightE |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptorTermStates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AcceptorTermStates = append(m.AcceptorTermStates, &AcceptorTermState{})
			if err := m.AcceptorTermStates[len(m.AcceptorTermStates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVeela(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVeela
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptorRpcPrepareRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVeela
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptorRpcPrepareRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptorRpcPrepareRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerID", wireType)
			}
			m.ProposerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposerID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptorID", wireType)
			}
			m.AcceptorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcceptorID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstE", wireType)
			}
			m.InstE = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstE |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareEpoch", wireType)
			}
			m.PrepareEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrepareEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlyRetureAcceptValueIDFlag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnlyRetureAcceptValueIDFlag = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipVeela(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVeela
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptorRpcPrepareResponese) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVeela
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptorRpcPrepareResponese: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptorRpcPrepareResponese: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromisedFlag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.PromisedFlag = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptorInOnePaxosInstanceState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AcceptorInOnePaxosInstanceState == nil {
				m.AcceptorInOnePaxosInstanceState = &AcceptorInOnePaxosInstanceState{}
			}
			if err := m.AcceptorInOnePaxosInstanceState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptValueIDMapToAcceptValueBs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AcceptValueIDMapToAcceptValueBs == nil {
				m.AcceptValueIDMapToAcceptValueBs = make(map[uint64][]byte)
			}
			var mapkey uint64
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVeela
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVeela
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVeela
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthVeela
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthVeela
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipVeela(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthVeela
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AcceptValueIDMapToAcceptValueBs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVeela(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVeela
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptorRpcAcceptRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVeela
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptorRpcAcceptRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptorRpcAcceptRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerID", wireType)
			}
			m.ProposerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposerID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptorID", wireType)
			}
			m.AcceptorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcceptorID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstE", wireType)
			}
			m.InstE = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstE |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreparedEpoch", wireType)
			}
			m.PreparedEpoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PreparedEpoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAcceptValueID", wireType)
			}
			m.ToAcceptValueID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToAcceptValueID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlyContainAcceptValueIDFlag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnlyContainAcceptValueIDFlag = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToAcceptValueBs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ToAcceptValueBs = append(m.ToAcceptValueBs[:0], dAtA[iNdEx:postIndex]...)
			if m.ToAcceptValueBs == nil {
				m.ToAcceptValueBs = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVeela(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVeela
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptorRpcAcceptResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVeela
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptorRpcAcceptResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptorRpcAcceptResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptedFlag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AcceptedFlag = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptorInOnePaxosInstanceState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AcceptorInOnePaxosInstanceState == nil {
				m.AcceptorInOnePaxosInstanceState = &AcceptorInOnePaxosInstanceState{}
			}
			if err := m.AcceptorInOnePaxosInstanceState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVeela(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVeela
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptorRpcChosenNotifyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVeela
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptorRpcChosenNotifyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptorRpcChosenNotifyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerID", wireType)
			}
			m.ProposerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposerID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptorID", wireType)
			}
			m.AcceptorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcceptorID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstE", wireType)
			}
			m.InstE = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstE |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptValueID", wireType)
			}
			m.AcceptValueID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcceptValueID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlyContainAcceptValueIDFlag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnlyContainAcceptValueIDFlag = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptValueBs", wireType)
			}
			m.AcceptValueBs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcceptValueBs |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVeela(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVeela
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptorRpcChosenNotifyResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVeela
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptorRpcChosenNotifyResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptorRpcChosenNotifyResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChosenFlag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ChosenFlag = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipVeela(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVeela
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptorRpcGetAcceptValueByIDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVeela
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptorRpcGetAcceptValueByIDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptorRpcGetAcceptValueByIDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerID", wireType)
			}
			m.ProposerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposerID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptorID", wireType)
			}
			m.AcceptorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcceptorID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstE", wireType)
			}
			m.InstE = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InstE |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVeela
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.AcceptValueIDs = append(m.AcceptValueIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVeela
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthVeela
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthVeela
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.AcceptValueIDs) == 0 {
					m.AcceptValueIDs = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVeela
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.AcceptValueIDs = append(m.AcceptValueIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptValueIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVeela(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVeela
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptorRpcGetAcceptValueByIDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVeela
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptorRpcGetAcceptValueByIDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptorRpcGetAcceptValueByIDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptorInOnePaxosInstanceState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AcceptorInOnePaxosInstanceState == nil {
				m.AcceptorInOnePaxosInstanceState = &AcceptorInOnePaxosInstanceState{}
			}
			if err := m.AcceptorInOnePaxosInstanceState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptValueIDMapToAcceptValueBs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AcceptValueIDMapToAcceptValueBs == nil {
				m.AcceptValueIDMapToAcceptValueBs = make(map[uint64][]byte)
			}
			var mapkey uint64
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowVeela
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVeela
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowVeela
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthVeela
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthVeela
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipVeela(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthVeela
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AcceptValueIDMapToAcceptValueBs[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVeela(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVeela
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptorRpcGetSummaryRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVeela
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptorRpcGetSummaryRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptorRpcGetSummaryRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerID", wireType)
			}
			m.ProposerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposerID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AcceptorID", wireType)
			}
			m.AcceptorID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AcceptorID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlyGetTermsContainUnchosenInstFlag", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnlyGetTermsContainUnchosenInstFlag = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetInstEpochRangeLeftE", wireType)
			}
			m.GetInstEpochRangeLeftE = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GetInstEpochRangeLeftE |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetInstEpochRangeRightE", wireType)
			}
			m.GetInstEpochRangeRightE = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GetInstEpochRangeRightE |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipVeela(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVeela
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptorRpcGetSummaryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowVeela
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptorRpcGetSummaryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptorRpcGetSummaryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusCode", wireType)
			}
			m.StatusCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StatusCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrStr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrStr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Summary", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthVeela
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthVeela
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Summary == nil {
				m.Summary = &AcceptorStateSummary{}
			}
			if err := m.Summary.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipVeela(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthVeela
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipVeela(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowVeela
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowVeela
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthVeela
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupVeela
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthVeela
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthVeela        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowVeela          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupVeela = fmt.Errorf("proto: unexpected end of group")
)
